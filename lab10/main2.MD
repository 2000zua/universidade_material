# Gerador de N√∫meros Aleat√≥rios - M√©todo de Fibonacci com Atraso

## Introdu√ß√£o
O **M√©todo de Fibonacci com Atraso** (‚ÄúLagged Fibonacci Generator‚Äù - LFG) √© um algoritmo para gerar n√∫meros pseudoaleat√≥rios baseado na seguinte f√≥rmula recorrente:

\[
X_n = (X_{n - p} \; \text{op} \; X_{n - q}) \mod m
\]

Onde:
- \( p \) e \( q \) s√£o **atrasos (lags)**, onde \( p > q \).
- **op** pode ser soma (+), subtra√ß√£o (-), multiplica√ß√£o (*) ou XOR (\^).
- \( m \) √© o m√≥dulo (geralmente \( 2^{32} \) ou \( 2^{64} \)).

Este m√©todo √© amplamente utilizado devido √†s suas **boas propriedades estat√≠sticas** e ao longo per√≠odo de repeti√ß√£o, sendo aplicado em **criptografia, simula√ß√£o estat√≠stica e algoritmos de Monte Carlo**.

---

## Implementa√ß√£o em C++
O c√≥digo abaixo implementa um **Gerador de Fibonacci com Atraso** utilizando soma modular:

```cpp
#include <iostream>
#include <vector>
#include <ctime>

class LaggedFibonacciGenerator {
private:
    std::vector<uint32_t> state;
    size_t p, q, index;
    const uint32_t MODULUS = 1U << 31; // 2^31
    
public:
    // Construtor com p e q definidos
    LaggedFibonacciGenerator(size_t p_lag, size_t q_lag, uint32_t seed) : p(p_lag), q(q_lag), index(0) {
        if (p <= q) {
            throw std::invalid_argument("p deve ser maior que q!");
        }

        state.resize(p);
        state[0] = seed;

        // Inicializa o estado com um LCG simples
        for (size_t i = 1; i < p; ++i) {
            state[i] = (state[i - 1] * 1664525 + 1013904223) % MODULUS;
        }
    }

    // Gera um novo n√∫mero pseudoaleat√≥rio
    uint32_t next() {
        size_t pos_p = (index + p - q) % p;
        state[index] = (state[index] + state[pos_p]) % MODULUS;
        
        uint32_t result = state[index];
        index = (index + 1) % p;
        
        return result;
    }
};

int main() {
    uint32_t seed = static_cast<uint32_t>(time(nullptr));
    LaggedFibonacciGenerator lfg(55, 24, seed);

    std::cout << "Gerando 10 n√∫meros pseudoaleat√≥rios:\n";
    for (int i = 0; i < 10; ++i) {
        std::cout << lfg.next() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

---

## Explica√ß√£o do C√≥digo
1. **Inicializa√ß√£o**:
   - Criamos um vetor `state` de tamanho \( p \) para armazenar os valores anteriores.
   - Preenchemos `state` com uma sequ√™ncia gerada por um **LCG** (Linear Congruential Generator).

2. **Gera√ß√£o de N√∫meros**:
   - Utilizamos a f√≥rmula \( X_n = (X_{n-p} + X_{n-q}) \mod 2^{31} \).
   - Atualizamos o √≠ndice `index` ciclicamente, simulando um **buffer circular**.

3. **Execu√ß√£o**:
   - O programa inicializa o gerador com um seed baseado no tempo.
   - Gera e imprime **10 n√∫meros pseudoaleat√≥rios**.

---

## Vantagens do M√©todo Fibonacci com Atraso
‚úÖ **Melhores propriedades estat√≠sticas** que o gerador congruencial linear (LCG).  
‚úÖ **Grande per√≠odo de repeti√ß√£o** (‚âà \( 2^p \)), dificultando padr√µes.  
‚úÖ **Bom desempenho em simula√ß√£o e criptografia**.  

## Desvantagens
‚ùå **Mais lento que o LCG** devido ao uso de um buffer grande.  
‚ùå **Requer armazenamento de \( p \) valores anteriores**.  

---

## Aplica√ß√µes
üîπ Gera√ß√£o de n√∫meros aleat√≥rios para **criptografia**.  
üîπ **Simula√ß√£o estat√≠stica e f√≠sica**, como Monte Carlo.  
üîπ Modelagem de processos aleat√≥rios.  

---

## Conclus√£o
O **Gerador Fibonacci com Atraso** √© um algoritmo confi√°vel para gerar n√∫meros pseudoaleat√≥rios, sendo amplamente usado em aplica√ß√µes que exigem um **alto grau de aleatoriedade e um grande per√≠odo de gera√ß√£o**. üöÄ

