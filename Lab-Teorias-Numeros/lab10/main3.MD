# Gerador de N√∫meros Aleat√≥rios - M√©todo de Fibonacci com Atraso e M√©todo Blum-Blum-Shub

## Introdu√ß√£o
### M√©todo de Fibonacci com Atraso
O **M√©todo de Fibonacci com Atraso** ("Lagged Fibonacci Generator" - LFG) √© um algoritmo para gerar n√∫meros pseudoaleat√≥rios baseado na seguinte f√≥rmula recorrente:

\[
X_n = (X_{n - p} \; \text{op} \; X_{n - q}) \mod m
\]

Onde:
- \( p \) e \( q \) s√£o **atrasos (lags)**, onde \( p > q \).
- **op** pode ser soma (+), subtra√ß√£o (-), multiplica√ß√£o (*) ou XOR (^).
- \( m \) √© o m√≥dulo (geralmente \( 2^{32} \) ou \( 2^{64} \)).

Este m√©todo √© amplamente utilizado devido √†s suas **boas propriedades estat√≠sticas** e ao longo per√≠odo de repeti√ß√£o, sendo aplicado em **criptografia, simula√ß√£o estat√≠stica e algoritmos de Monte Carlo**.

### M√©todo Blum-Blum-Shub (BBS)
O **Blum-Blum-Shub (BBS)** √© um gerador de n√∫meros pseudoaleat√≥rios baseado na dificuldade do problema da fatora√ß√£o de grandes n√∫meros. Ele √© definido pela seguinte equa√ß√£o:

\[
X_{n+1} = (X_n^2) \mod M
\]

Onde:
- \( M = p \times q \) √© o produto de dois grandes n√∫meros primos \( p \) e \( q \), ambos congruentes a 3 mod 4.
- \( X_0 \) √© a semente, escolhida como um n√∫mero coprimo de \( M \).

Este m√©todo √© altamente seguro e √© utilizado em **criptografia**, sendo considerado um dos mais fortes geradores pseudoaleat√≥rios dispon√≠veis.

---

## Implementa√ß√£o em C++

### Gerador de Fibonacci com Atraso

```cpp
#include <iostream>
#include <vector>
#include <ctime>

class LaggedFibonacciGenerator {
private:
    std::vector<uint32_t> state;
    size_t p, q, index;
    const uint32_t MODULUS = 1U << 31; // 2^31
    
public:
    // Construtor com p e q definidos
    LaggedFibonacciGenerator(size_t p_lag, size_t q_lag, uint32_t seed) : p(p_lag), q(q_lag), index(0) {
        if (p <= q) {
            throw std::invalid_argument("p deve ser maior que q!");
        }

        state.resize(p);
        state[0] = seed;

        // Inicializa o estado com um LCG simples
        for (size_t i = 1; i < p; ++i) {
            state[i] = (state[i - 1] * 1664525 + 1013904223) % MODULUS;
        }
    }

    // Gera um novo n√∫mero pseudoaleat√≥rio
    uint32_t next() {
        size_t pos_p = (index + p - q) % p;
        state[index] = (state[index] + state[pos_p]) % MODULUS;
        
        uint32_t result = state[index];
        index = (index + 1) % p;
        
        return result;
    }
};
```

### Gerador Blum-Blum-Shub

```cpp
#include <iostream>
#include <cmath>

class BlumBlumShub {
private:
    long long M, state;

public:
    BlumBlumShub(long long p, long long q, long long seed) {
        M = p * q;
        state = (seed * seed) % M;
    }

    int next() {
        state = (state * state) % M;
        return state & 1; // Retorna o √∫ltimo bit gerado
    }
};

int main() {
    long long p = 11, q = 19; // Exemplo de primos pequenos para teste
    long long seed = 3;
    BlumBlumShub bbs(p, q, seed);
    
    std::cout << "Gerando 10 bits pseudoaleat√≥rios:\n";
    for (int i = 0; i < 10; ++i) {
        std::cout << bbs.next() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

---

## Compara√ß√£o dos M√©todos

| M√©todo | Velocidade | Comprimento do Per√≠odo | Lei de Distribui√ß√£o |
|--------|-----------|----------------------|--------------------|
| **Fibonacci com Atraso** | R√°pido, devido a opera√ß√µes aritm√©ticas simples | Muito longo, depende dos valores de \( p \) e \( q \) | Aproxima√ß√£o de uma distribui√ß√£o uniforme |
| **Blum-Blum-Shub** | Lento, pois envolve opera√ß√µes modulares de grandes n√∫meros | Extremamente longo, dependendo da escolha de \( p \) e \( q \) | Distribui√ß√£o uniforme de bits, adequado para criptografia |

---

## Conclus√£o
O **Gerador Fibonacci com Atraso** √© um m√©todo confi√°vel para simula√ß√£o estat√≠stica, enquanto o **Blum-Blum-Shub** √© uma op√ß√£o segura para criptografia. Ambos desempenham pap√©is importantes em diferentes √°reas de aplica√ß√£o. üöÄ

